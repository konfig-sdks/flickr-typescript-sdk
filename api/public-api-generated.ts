/* tslint:disable */
/* eslint-disable */
/*
Flickr API Schema

A subset of Flickr's API defined in Swagger format.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { PublicFlickrGroupsPoolsGetContextResponse } from '../models';
// @ts-ignore
import { PublicGetAlbumPhotosResponse } from '../models';
// @ts-ignore
import { PublicGetFavoritePhotosResponse } from '../models';
// @ts-ignore
import { PublicGetFavoritesContextResponse } from '../models';
// @ts-ignore
import { PublicGetFlickrTestEchoResponse } from '../models';
// @ts-ignore
import { PublicGetGalleryPhotosResponse } from '../models';
// @ts-ignore
import { PublicGetGroupDiscussionTopicsResponse } from '../models';
// @ts-ignore
import { PublicGetGroupInfoResponse } from '../models';
// @ts-ignore
import { PublicGetGroupPoolPhotosResponse } from '../models';
// @ts-ignore
import { PublicGetGroupTopicInfoResponse } from '../models';
// @ts-ignore
import { PublicGetGroupTopicRepliesInfoResponse } from '../models';
// @ts-ignore
import { PublicGetPersonInformationResponse } from '../models';
// @ts-ignore
import { PublicGetPhotoExifResponse } from '../models';
// @ts-ignore
import { PublicGetPhotoInfoResponse } from '../models';
// @ts-ignore
import { PublicGetPhotoLicensesResponse } from '../models';
// @ts-ignore
import { PublicGetPhotoListContextResponse } from '../models';
// @ts-ignore
import { PublicGetPhotoSetContextResponse } from '../models';
// @ts-ignore
import { PublicGetPhotoSizesResponse } from '../models';
// @ts-ignore
import { PublicGetPhotostreamContextResponse } from '../models';
// @ts-ignore
import { PublicGetUserAlbumsResponse } from '../models';
// @ts-ignore
import { PublicGetUserPhotosResponse } from '../models';
// @ts-ignore
import { PublicSearchPhotosResponse } from '../models';
// @ts-ignore
import { PublicUploadPhotoRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns next and previous photos for a photo in a group pool
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flickrGroupsPoolsGetContext: async (apiKey: string, photoId: string, groupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('flickrGroupsPoolsGetContext', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('flickrGroupsPoolsGetContext', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.groups.pools.getContext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.groups.pools.getContext',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an access token
         * @param {string} oauthConsumerKey 
         * @param {string} oauthNonce 
         * @param {string} oauthTimestamp 
         * @param {string} oauthSignatureMethod 
         * @param {string} oauthVersion 
         * @param {string} oauthSignature 
         * @param {string} oauthVerifier 
         * @param {string} oauthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (oauthConsumerKey: string, oauthNonce: string, oauthTimestamp: string, oauthSignatureMethod: string, oauthVersion: string, oauthSignature: string, oauthVerifier: string, oauthToken: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauthConsumerKey' is not null or undefined
            assertParamExists('getAccessToken', 'oauthConsumerKey', oauthConsumerKey)
            // verify required parameter 'oauthNonce' is not null or undefined
            assertParamExists('getAccessToken', 'oauthNonce', oauthNonce)
            // verify required parameter 'oauthTimestamp' is not null or undefined
            assertParamExists('getAccessToken', 'oauthTimestamp', oauthTimestamp)
            // verify required parameter 'oauthSignatureMethod' is not null or undefined
            assertParamExists('getAccessToken', 'oauthSignatureMethod', oauthSignatureMethod)
            // verify required parameter 'oauthVersion' is not null or undefined
            assertParamExists('getAccessToken', 'oauthVersion', oauthVersion)
            // verify required parameter 'oauthSignature' is not null or undefined
            assertParamExists('getAccessToken', 'oauthSignature', oauthSignature)
            // verify required parameter 'oauthVerifier' is not null or undefined
            assertParamExists('getAccessToken', 'oauthVerifier', oauthVerifier)
            // verify required parameter 'oauthToken' is not null or undefined
            assertParamExists('getAccessToken', 'oauthToken', oauthToken)
            const localVarPath = `/oauth/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (oauthConsumerKey !== undefined) {
                localVarQueryParameter['oauth_consumer_key'] = oauthConsumerKey;
            }

            if (oauthNonce !== undefined) {
                localVarQueryParameter['oauth_nonce'] = oauthNonce;
            }

            if (oauthTimestamp !== undefined) {
                localVarQueryParameter['oauth_timestamp'] = oauthTimestamp;
            }

            if (oauthSignatureMethod !== undefined) {
                localVarQueryParameter['oauth_signature_method'] = oauthSignatureMethod;
            }

            if (oauthVersion !== undefined) {
                localVarQueryParameter['oauth_version'] = oauthVersion;
            }

            if (oauthSignature !== undefined) {
                localVarQueryParameter['oauth_signature'] = oauthSignature;
            }

            if (oauthVerifier !== undefined) {
                localVarQueryParameter['oauth_verifier'] = oauthVerifier;
            }

            if (oauthToken !== undefined) {
                localVarQueryParameter['oauth_token'] = oauthToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/oauth/access_token',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of photos in an album.
         * @param {string} apiKey 
         * @param {string} photosetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumPhotos: async (apiKey: string, photosetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getAlbumPhotos', 'apiKey', apiKey)
            // verify required parameter 'photosetId' is not null or undefined
            assertParamExists('getAlbumPhotos', 'photosetId', photosetId)
            const localVarPath = `/rest?method=flickr.photosets.getPhotos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photosetId !== undefined) {
                localVarQueryParameter['photoset_id'] = photosetId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photosets.getPhotos',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the user\'s favorite photos. Only photos which the calling user has permission to see are returned.
         * @param {string} apiKey 
         * @param {string} userId 
         * @param {number} [minFaveDate] 
         * @param {number} [maxFaveDate] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritePhotos: async (apiKey: string, userId: string, minFaveDate?: number, maxFaveDate?: number, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getFavoritePhotos', 'apiKey', apiKey)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFavoritePhotos', 'userId', userId)
            const localVarPath = `/rest?method=flickr.favorites.getList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (minFaveDate !== undefined) {
                localVarQueryParameter['min_fave_date'] = minFaveDate;
            }

            if (maxFaveDate !== undefined) {
                localVarQueryParameter['max_fave_date'] = maxFaveDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.favorites.getList',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns next and previous favorites for a photo in a user\'s favorites
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritesContext: async (apiKey: string, photoId: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getFavoritesContext', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getFavoritesContext', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.favorites.getContext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.favorites.getContext',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Echos the input parameters back in the response
         * @param {string} apiKey 
         * @param {string} [echo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlickrTestEcho: async (apiKey: string, echo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getFlickrTestEcho', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.test.echo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (echo !== undefined) {
                localVarQueryParameter['echo'] = echo;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.test.echo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of photos in a gallery.
         * @param {string} apiKey 
         * @param {string} galleryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGalleryPhotos: async (apiKey: string, galleryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getGalleryPhotos', 'apiKey', apiKey)
            // verify required parameter 'galleryId' is not null or undefined
            assertParamExists('getGalleryPhotos', 'galleryId', galleryId)
            const localVarPath = `/rest?method=flickr.galleries.getPhotos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (galleryId !== undefined) {
                localVarQueryParameter['gallery_id'] = galleryId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.galleries.getPhotos',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of discussion topics in a group.
         * @param {string} apiKey 
         * @param {string} [groupId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDiscussionTopics: async (apiKey: string, groupId?: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getGroupDiscussionTopics', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.groups.discuss.topics.getList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.groups.discuss.topics.getList',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a group
         * @param {string} apiKey 
         * @param {string} [groupId] 
         * @param {string} [groupPathAlias] 
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInfo: async (apiKey: string, groupId?: string, groupPathAlias?: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getGroupInfo', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.groups.getInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (groupPathAlias !== undefined) {
                localVarQueryParameter['group_path_alias'] = groupPathAlias;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.groups.getInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of pool photos for a given group
         * @param {string} apiKey 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPoolPhotos: async (apiKey: string, groupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getGroupPoolPhotos', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.groups.pools.getPhotos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.groups.pools.getPhotos',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a group discussion topic
         * @param {string} apiKey 
         * @param {string} topicId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupTopicInfo: async (apiKey: string, topicId: string, groupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getGroupTopicInfo', 'apiKey', apiKey)
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getGroupTopicInfo', 'topicId', topicId)
            const localVarPath = `/rest?method=flickr.groups.discuss.topics.getInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.groups.discuss.topics.getInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a group topic reply
         * @param {string} apiKey 
         * @param {string} topicId 
         * @param {string} replyId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupTopicRepliesInfo: async (apiKey: string, topicId: string, replyId: string, groupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getGroupTopicRepliesInfo', 'apiKey', apiKey)
            // verify required parameter 'topicId' is not null or undefined
            assertParamExists('getGroupTopicRepliesInfo', 'topicId', topicId)
            // verify required parameter 'replyId' is not null or undefined
            assertParamExists('getGroupTopicRepliesInfo', 'replyId', replyId)
            const localVarPath = `/rest?method=flickr.groups.discuss.replies.getInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (topicId !== undefined) {
                localVarQueryParameter['topic_id'] = topicId;
            }

            if (replyId !== undefined) {
                localVarQueryParameter['reply_id'] = replyId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.groups.discuss.replies.getInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an oauth token and oauth token secret
         * @param {string} oauthConsumerKey 
         * @param {string} oauthNonce 
         * @param {string} oauthTimestamp 
         * @param {string} oauthSignatureMethod 
         * @param {string} oauthVersion 
         * @param {string} oauthSignature 
         * @param {string} oauthCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthToken: async (oauthConsumerKey: string, oauthNonce: string, oauthTimestamp: string, oauthSignatureMethod: string, oauthVersion: string, oauthSignature: string, oauthCallback: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauthConsumerKey' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthConsumerKey', oauthConsumerKey)
            // verify required parameter 'oauthNonce' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthNonce', oauthNonce)
            // verify required parameter 'oauthTimestamp' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthTimestamp', oauthTimestamp)
            // verify required parameter 'oauthSignatureMethod' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthSignatureMethod', oauthSignatureMethod)
            // verify required parameter 'oauthVersion' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthVersion', oauthVersion)
            // verify required parameter 'oauthSignature' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthSignature', oauthSignature)
            // verify required parameter 'oauthCallback' is not null or undefined
            assertParamExists('getOAuthToken', 'oauthCallback', oauthCallback)
            const localVarPath = `/oauth/request_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (oauthConsumerKey !== undefined) {
                localVarQueryParameter['oauth_consumer_key'] = oauthConsumerKey;
            }

            if (oauthNonce !== undefined) {
                localVarQueryParameter['oauth_nonce'] = oauthNonce;
            }

            if (oauthTimestamp !== undefined) {
                localVarQueryParameter['oauth_timestamp'] = oauthTimestamp;
            }

            if (oauthSignatureMethod !== undefined) {
                localVarQueryParameter['oauth_signature_method'] = oauthSignatureMethod;
            }

            if (oauthVersion !== undefined) {
                localVarQueryParameter['oauth_version'] = oauthVersion;
            }

            if (oauthSignature !== undefined) {
                localVarQueryParameter['oauth_signature'] = oauthSignature;
            }

            if (oauthCallback !== undefined) {
                localVarQueryParameter['oauth_callback'] = oauthCallback;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/oauth/request_token',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a person
         * @param {string} apiKey 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonInformation: async (apiKey: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPersonInformation', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.people.getInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.people.getInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoExif: async (apiKey: string, photoId: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotoExif', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhotoExif', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.photos.getExif`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photos.getExif',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a photo
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoInfo: async (apiKey: string, photoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotoInfo', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhotoInfo', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.photos.getInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photos.getInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of available photo licenses for Flickr
         * @param {string} apiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoLicenses: async (apiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotoLicenses', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.photos.licenses.getInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photos.licenses.getInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns next and previous photos in a photo list
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {string} photolistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoListContext: async (apiKey: string, photoId: string, photolistId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotoListContext', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhotoListContext', 'photoId', photoId)
            // verify required parameter 'photolistId' is not null or undefined
            assertParamExists('getPhotoListContext', 'photolistId', photolistId)
            const localVarPath = `/rest?method=flickr.photolist.getContext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }

            if (photolistId !== undefined) {
                localVarQueryParameter['photolist_id'] = photolistId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photolist.getContext',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns next and previous photos for a photo in a set
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {string} [photosetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoSetContext: async (apiKey: string, photoId: string, photosetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotoSetContext', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhotoSetContext', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.photosets.getContext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }

            if (photosetId !== undefined) {
                localVarQueryParameter['photoset_id'] = photosetId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photosets.getContext',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns photo sizes
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoSizes: async (apiKey: string, photoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotoSizes', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhotoSizes', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.photos.getSizes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photos.getSizes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns next and previous photos for a photo in a photostream
         * @param {string} apiKey 
         * @param {string} photoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotostreamContext: async (apiKey: string, photoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getPhotostreamContext', 'apiKey', apiKey)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhotostreamContext', 'photoId', photoId)
            const localVarPath = `/rest?method=flickr.photos.getContext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (photoId !== undefined) {
                localVarQueryParameter['photo_id'] = photoId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photos.getContext',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the albums belonging to the specified user
         * @param {string} apiKey 
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAlbums: async (apiKey: string, userId: string, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getUserAlbums', 'apiKey', apiKey)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAlbums', 'userId', userId)
            const localVarPath = `/rest?method=flickr.photosets.getList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photosets.getList',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return photos from the given user\'s photostream
         * @param {string} apiKey 
         * @param {string} userId 
         * @param {number} [safeSearch] 
         * @param {number} [minUploadDate] 
         * @param {number} [maxUploadDate] 
         * @param {number} [minTakenDate] 
         * @param {number} [maxTakenDate] 
         * @param {number} [contentType] 
         * @param {number} [privacyFilter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPhotos: async (apiKey: string, userId: string, safeSearch?: number, minUploadDate?: number, maxUploadDate?: number, minTakenDate?: number, maxTakenDate?: number, contentType?: number, privacyFilter?: number, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getUserPhotos', 'apiKey', apiKey)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserPhotos', 'userId', userId)
            const localVarPath = `/rest?method=flickr.people.getPhotos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (safeSearch !== undefined) {
                localVarQueryParameter['safe_search'] = safeSearch;
            }

            if (minUploadDate !== undefined) {
                localVarQueryParameter['min_upload_date'] = minUploadDate;
            }

            if (maxUploadDate !== undefined) {
                localVarQueryParameter['max_upload_date'] = maxUploadDate;
            }

            if (minTakenDate !== undefined) {
                localVarQueryParameter['min_taken_date'] = minTakenDate;
            }

            if (maxTakenDate !== undefined) {
                localVarQueryParameter['max_taken_date'] = maxTakenDate;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (privacyFilter !== undefined) {
                localVarQueryParameter['privacy_filter'] = privacyFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.people.getPhotos',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of photos matching some criteria.
         * @param {string} apiKey 
         * @param {string} [text] A free text search. Photos who\&#39;s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character.
         * @param {string} [tags] A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character.
         * @param {string} [userId] The NSID of the user who\&#39;s photo to search. If this parameter isn\&#39;t passed then everybody\&#39;s public photos will be searched. A value of \&quot;me\&quot; will search against the calling user\&#39;s photos for authenticated calls.
         * @param {string} [minUploadDate] Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime.
         * @param {string} [maxUploadDate] Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime.
         * @param {string} [minTakenDate] Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp.
         * @param {string} [maxTakenDate] Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp.
         * @param {string} [license] The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated.
         * @param {string} [sort] The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance. 
         * @param {number} [privacyFilter] Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends &amp; family,   5: completely private photos 
         * @param {string} [bbox] A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched.
         * @param {string} [accuracy] Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16 
         * @param {number} [safeSearch] Safe search setting:   1: for safe,   2: for moderate,   3: for restricted 
         * @param {number} [contentType] Content Type setting:   1: photos only.   2: screenshots only.   3: \&#39;other\&#39; only.   4: photos and screenshots.   5: screenshots and \&#39;other\&#39;.   6: photos and \&#39;other\&#39;.   7: photos, screenshots, and \&#39;other\&#39; (all). 
         * @param {string} [machineTags] Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the \&#39;dc\&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:\&quot; Find photos with a title in the \&#39;dc\&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\&quot; Find photos titled \&quot;mr. camera\&quot; in the \&#39;dc\&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\\\&quot;mr. camera\\\&quot; Find photos whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos that have a title, in any namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\&quot; Find photos that have a title, in any namespace, whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos, in the \&#39;dc\&#39; namespace whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \&quot;AND\&quot; queries are limited to (16) machine tags. \&quot;OR\&quot; queries are limited to (8). 
         * @param {string} [machineTagMode] Either \&#39;any\&#39; for an OR combination of tags, or \&#39;all\&#39; for an AND combination. Defaults to \&#39;any\&#39; if not specified.
         * @param {string} [groupId] The id of a group who\&#39;s pool to search. If specified, only matching photos posted to the group\&#39;s pool will be returned.
         * @param {string} [contacts] Search your contacts. Either \&#39;all\&#39; or \&#39;ff\&#39; for just friends and family. (Experimental)
         * @param {string} [woeId] A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present).
         * @param {string} [placeId] A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
         * @param {string} [media] Filter results by media type. Possible values are all (default), photos or videos
         * @param {string} [hasGeo] Any photo that has been geotagged, or if the value is \&quot;0\&quot; any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
         * @param {string} [geoContext] Geo context is a numeric value representing the photo\&#39;s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \&quot;indoors\&quot; or \&quot;outdoors\&quot;. The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
         * @param {string} [lat] A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
         * @param {string} [lon] A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
         * @param {number} [radius] A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km).
         * @param {string} [radiusUnits] The unit of measure when doing radial geo queries. Valid options are \&quot;mi\&quot; (miles) and \&quot;km\&quot; (kilometers). The default is \&quot;km\&quot;.
         * @param {boolean} [isCommons] Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false.
         * @param {boolean} [inGallery] Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos.
         * @param {boolean} [isGetty] Limit the scope of the search to only photos that are for sale on Getty. Default is false.
         * @param {number} [perPage] Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500.
         * @param {number} [page] The page of results to return. If this argument is omitted, it defaults to 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPhotos: async (apiKey: string, text?: string, tags?: string, userId?: string, minUploadDate?: string, maxUploadDate?: string, minTakenDate?: string, maxTakenDate?: string, license?: string, sort?: string, privacyFilter?: number, bbox?: string, accuracy?: string, safeSearch?: number, contentType?: number, machineTags?: string, machineTagMode?: string, groupId?: string, contacts?: string, woeId?: string, placeId?: string, media?: string, hasGeo?: string, geoContext?: string, lat?: string, lon?: string, radius?: number, radiusUnits?: string, isCommons?: boolean, inGallery?: boolean, isGetty?: boolean, perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('searchPhotos', 'apiKey', apiKey)
            const localVarPath = `/rest?method=flickr.photos.search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['api_key'] = apiKey;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (minUploadDate !== undefined) {
                localVarQueryParameter['min_upload_date'] = minUploadDate;
            }

            if (maxUploadDate !== undefined) {
                localVarQueryParameter['max_upload_date'] = maxUploadDate;
            }

            if (minTakenDate !== undefined) {
                localVarQueryParameter['min_taken_date'] = minTakenDate;
            }

            if (maxTakenDate !== undefined) {
                localVarQueryParameter['max_taken_date'] = maxTakenDate;
            }

            if (license !== undefined) {
                localVarQueryParameter['license'] = license;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (privacyFilter !== undefined) {
                localVarQueryParameter['privacy_filter'] = privacyFilter;
            }

            if (bbox !== undefined) {
                localVarQueryParameter['bbox'] = bbox;
            }

            if (accuracy !== undefined) {
                localVarQueryParameter['accuracy'] = accuracy;
            }

            if (safeSearch !== undefined) {
                localVarQueryParameter['safe_search'] = safeSearch;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (machineTags !== undefined) {
                localVarQueryParameter['machine_tags'] = machineTags;
            }

            if (machineTagMode !== undefined) {
                localVarQueryParameter['machine_tag_mode'] = machineTagMode;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (woeId !== undefined) {
                localVarQueryParameter['woe_id'] = woeId;
            }

            if (placeId !== undefined) {
                localVarQueryParameter['place_id'] = placeId;
            }

            if (media !== undefined) {
                localVarQueryParameter['media'] = media;
            }

            if (hasGeo !== undefined) {
                localVarQueryParameter['has_geo'] = hasGeo;
            }

            if (geoContext !== undefined) {
                localVarQueryParameter['geo_context'] = geoContext;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (radiusUnits !== undefined) {
                localVarQueryParameter['radius_units'] = radiusUnits;
            }

            if (isCommons !== undefined) {
                localVarQueryParameter['is_commons'] = isCommons;
            }

            if (inGallery !== undefined) {
                localVarQueryParameter['in_gallery'] = inGallery;
            }

            if (isGetty !== undefined) {
                localVarQueryParameter['is_getty'] = isGetty;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/rest?method=flickr.photos.search',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a new photo to Flickr
         * @param {string} apiKey 
         * @param {Uint8Array | File | buffer.File} photo 
         * @param {PublicUploadPhotoRequest} publicUploadPhotoRequest 
         * @param {string} [tags] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [contentType] 
         * @param {string} [hidden] 
         * @param {string} [isFamily] 
         * @param {string} [isFriend] 
         * @param {string} [isPublic] 
         * @param {string} [safetyLevel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhoto: async (apiKey: string, photo: Uint8Array | File | buffer.File, publicUploadPhotoRequest: PublicUploadPhotoRequest, tags?: string, title?: string, description?: string, contentType?: string, hidden?: string, isFamily?: string, isFriend?: string, isPublic?: string, safetyLevel?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('uploadPhoto', 'apiKey', apiKey)
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('uploadPhoto', 'photo', photo)
            // verify required parameter 'publicUploadPhotoRequest' is not null or undefined
            assertParamExists('uploadPhoto', 'publicUploadPhotoRequest', publicUploadPhotoRequest)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());


            if (tags !== undefined) {
                await addFormParam('tags', tags, false, true)
            }
    
            if (title !== undefined) {
                await addFormParam('title', title, false, true)
            }
    
            if (description !== undefined) {
                await addFormParam('description', description, false, true)
            }
    
            if (apiKey !== undefined) {
                await addFormParam('api_key', apiKey, false, true)
            }
    
            if (contentType !== undefined) {
                await addFormParam('content_type', contentType, false, true)
            }
    
            if (hidden !== undefined) {
                await addFormParam('hidden', hidden, false, true)
            }
    
            if (isFamily !== undefined) {
                await addFormParam('is_family', isFamily, false, true)
            }
    
            if (isFriend !== undefined) {
                await addFormParam('is_friend', isFriend, false, true)
            }
    
            if (isPublic !== undefined) {
                await addFormParam('is_public', isPublic, false, true)
            }
    
            if (photo !== undefined) {
                await addFormParam('photo', photo, true, true)
            }
    
            if (safetyLevel !== undefined) {
                await addFormParam('safety_level', safetyLevel, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: publicUploadPhotoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/upload',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns next and previous photos for a photo in a group pool
         * @param {PublicApiFlickrGroupsPoolsGetContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flickrGroupsPoolsGetContext(requestParameters: PublicApiFlickrGroupsPoolsGetContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicFlickrGroupsPoolsGetContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flickrGroupsPoolsGetContext(requestParameters.apiKey, requestParameters.photoId, requestParameters.groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an access token
         * @param {PublicApiGetAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(requestParameters: PublicApiGetAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(requestParameters.oauthConsumerKey, requestParameters.oauthNonce, requestParameters.oauthTimestamp, requestParameters.oauthSignatureMethod, requestParameters.oauthVersion, requestParameters.oauthSignature, requestParameters.oauthVerifier, requestParameters.oauthToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of photos in an album.
         * @param {PublicApiGetAlbumPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumPhotos(requestParameters: PublicApiGetAlbumPhotosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetAlbumPhotosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumPhotos(requestParameters.apiKey, requestParameters.photosetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of the user\'s favorite photos. Only photos which the calling user has permission to see are returned.
         * @param {PublicApiGetFavoritePhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoritePhotos(requestParameters: PublicApiGetFavoritePhotosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetFavoritePhotosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritePhotos(requestParameters.apiKey, requestParameters.userId, requestParameters.minFaveDate, requestParameters.maxFaveDate, requestParameters.page, requestParameters.perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns next and previous favorites for a photo in a user\'s favorites
         * @param {PublicApiGetFavoritesContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoritesContext(requestParameters: PublicApiGetFavoritesContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetFavoritesContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritesContext(requestParameters.apiKey, requestParameters.photoId, requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Echos the input parameters back in the response
         * @param {PublicApiGetFlickrTestEchoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlickrTestEcho(requestParameters: PublicApiGetFlickrTestEchoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetFlickrTestEchoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlickrTestEcho(requestParameters.apiKey, requestParameters.echo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of photos in a gallery.
         * @param {PublicApiGetGalleryPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGalleryPhotos(requestParameters: PublicApiGetGalleryPhotosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetGalleryPhotosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGalleryPhotos(requestParameters.apiKey, requestParameters.galleryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of discussion topics in a group.
         * @param {PublicApiGetGroupDiscussionTopicsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupDiscussionTopics(requestParameters: PublicApiGetGroupDiscussionTopicsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetGroupDiscussionTopicsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupDiscussionTopics(requestParameters.apiKey, requestParameters.groupId, requestParameters.page, requestParameters.perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a group
         * @param {PublicApiGetGroupInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupInfo(requestParameters: PublicApiGetGroupInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetGroupInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupInfo(requestParameters.apiKey, requestParameters.groupId, requestParameters.groupPathAlias, requestParameters.lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of pool photos for a given group
         * @param {PublicApiGetGroupPoolPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPoolPhotos(requestParameters: PublicApiGetGroupPoolPhotosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetGroupPoolPhotosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPoolPhotos(requestParameters.apiKey, requestParameters.groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a group discussion topic
         * @param {PublicApiGetGroupTopicInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupTopicInfo(requestParameters: PublicApiGetGroupTopicInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetGroupTopicInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupTopicInfo(requestParameters.apiKey, requestParameters.topicId, requestParameters.groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information on a group topic reply
         * @param {PublicApiGetGroupTopicRepliesInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupTopicRepliesInfo(requestParameters: PublicApiGetGroupTopicRepliesInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetGroupTopicRepliesInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupTopicRepliesInfo(requestParameters.apiKey, requestParameters.topicId, requestParameters.replyId, requestParameters.groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an oauth token and oauth token secret
         * @param {PublicApiGetOAuthTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthToken(requestParameters: PublicApiGetOAuthTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthToken(requestParameters.oauthConsumerKey, requestParameters.oauthNonce, requestParameters.oauthTimestamp, requestParameters.oauthSignatureMethod, requestParameters.oauthVersion, requestParameters.oauthSignature, requestParameters.oauthCallback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a person
         * @param {PublicApiGetPersonInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonInformation(requestParameters: PublicApiGetPersonInformationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPersonInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonInformation(requestParameters.apiKey, requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
         * @param {PublicApiGetPhotoExifRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoExif(requestParameters: PublicApiGetPhotoExifRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotoExifResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotoExif(requestParameters.apiKey, requestParameters.photoId, requestParameters.secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a photo
         * @param {PublicApiGetPhotoInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoInfo(requestParameters: PublicApiGetPhotoInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotoInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotoInfo(requestParameters.apiKey, requestParameters.photoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a list of available photo licenses for Flickr
         * @param {PublicApiGetPhotoLicensesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoLicenses(requestParameters: PublicApiGetPhotoLicensesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotoLicensesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotoLicenses(requestParameters.apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns next and previous photos in a photo list
         * @param {PublicApiGetPhotoListContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoListContext(requestParameters: PublicApiGetPhotoListContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotoListContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotoListContext(requestParameters.apiKey, requestParameters.photoId, requestParameters.photolistId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns next and previous photos for a photo in a set
         * @param {PublicApiGetPhotoSetContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoSetContext(requestParameters: PublicApiGetPhotoSetContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotoSetContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotoSetContext(requestParameters.apiKey, requestParameters.photoId, requestParameters.photosetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns photo sizes
         * @param {PublicApiGetPhotoSizesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoSizes(requestParameters: PublicApiGetPhotoSizesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotoSizesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotoSizes(requestParameters.apiKey, requestParameters.photoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns next and previous photos for a photo in a photostream
         * @param {PublicApiGetPhotostreamContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotostreamContext(requestParameters: PublicApiGetPhotostreamContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetPhotostreamContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhotostreamContext(requestParameters.apiKey, requestParameters.photoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the albums belonging to the specified user
         * @param {PublicApiGetUserAlbumsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAlbums(requestParameters: PublicApiGetUserAlbumsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetUserAlbumsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAlbums(requestParameters.apiKey, requestParameters.userId, requestParameters.page, requestParameters.perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return photos from the given user\'s photostream
         * @param {PublicApiGetUserPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPhotos(requestParameters: PublicApiGetUserPhotosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicGetUserPhotosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPhotos(requestParameters.apiKey, requestParameters.userId, requestParameters.safeSearch, requestParameters.minUploadDate, requestParameters.maxUploadDate, requestParameters.minTakenDate, requestParameters.maxTakenDate, requestParameters.contentType, requestParameters.privacyFilter, requestParameters.page, requestParameters.perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of photos matching some criteria.
         * @param {PublicApiSearchPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPhotos(requestParameters: PublicApiSearchPhotosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicSearchPhotosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPhotos(requestParameters.apiKey, requestParameters.text, requestParameters.tags, requestParameters.userId, requestParameters.minUploadDate, requestParameters.maxUploadDate, requestParameters.minTakenDate, requestParameters.maxTakenDate, requestParameters.license, requestParameters.sort, requestParameters.privacyFilter, requestParameters.bbox, requestParameters.accuracy, requestParameters.safeSearch, requestParameters.contentType, requestParameters.machineTags, requestParameters.machineTagMode, requestParameters.groupId, requestParameters.contacts, requestParameters.woeId, requestParameters.placeId, requestParameters.media, requestParameters.hasGeo, requestParameters.geoContext, requestParameters.lat, requestParameters.lon, requestParameters.radius, requestParameters.radiusUnits, requestParameters.isCommons, requestParameters.inGallery, requestParameters.isGetty, requestParameters.perPage, requestParameters.page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploads a new photo to Flickr
         * @param {PublicApiUploadPhotoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPhoto(requestParameters: PublicApiUploadPhotoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const publicUploadPhotoRequest: PublicUploadPhotoRequest = {
                tags: requestParameters.tags,
                title: requestParameters.title,
                description: requestParameters.description,
                api_key: requestParameters.api_key,
                content_type: requestParameters.content_type,
                hidden: requestParameters.hidden,
                is_family: requestParameters.is_family,
                is_friend: requestParameters.is_friend,
                is_public: requestParameters.is_public,
                photo: requestParameters.photo,
                safety_level: requestParameters.safety_level
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPhoto(requestParameters.apiKey, requestParameters.photo, publicUploadPhotoRequest, requestParameters.tags, requestParameters.title, requestParameters.description, requestParameters.contentType, requestParameters.hidden, requestParameters.isFamily, requestParameters.isFriend, requestParameters.isPublic, requestParameters.safetyLevel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * Returns next and previous photos for a photo in a group pool
         * @param {PublicApiFlickrGroupsPoolsGetContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flickrGroupsPoolsGetContext(requestParameters: PublicApiFlickrGroupsPoolsGetContextRequest, options?: AxiosRequestConfig): AxiosPromise<PublicFlickrGroupsPoolsGetContextResponse> {
            return localVarFp.flickrGroupsPoolsGetContext(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an access token
         * @param {PublicApiGetAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(requestParameters: PublicApiGetAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getAccessToken(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of photos in an album.
         * @param {PublicApiGetAlbumPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumPhotos(requestParameters: PublicApiGetAlbumPhotosRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetAlbumPhotosResponse> {
            return localVarFp.getAlbumPhotos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the user\'s favorite photos. Only photos which the calling user has permission to see are returned.
         * @param {PublicApiGetFavoritePhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritePhotos(requestParameters: PublicApiGetFavoritePhotosRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetFavoritePhotosResponse> {
            return localVarFp.getFavoritePhotos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns next and previous favorites for a photo in a user\'s favorites
         * @param {PublicApiGetFavoritesContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritesContext(requestParameters: PublicApiGetFavoritesContextRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetFavoritesContextResponse> {
            return localVarFp.getFavoritesContext(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Echos the input parameters back in the response
         * @param {PublicApiGetFlickrTestEchoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlickrTestEcho(requestParameters: PublicApiGetFlickrTestEchoRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetFlickrTestEchoResponse> {
            return localVarFp.getFlickrTestEcho(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of photos in a gallery.
         * @param {PublicApiGetGalleryPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGalleryPhotos(requestParameters: PublicApiGetGalleryPhotosRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetGalleryPhotosResponse> {
            return localVarFp.getGalleryPhotos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of discussion topics in a group.
         * @param {PublicApiGetGroupDiscussionTopicsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDiscussionTopics(requestParameters: PublicApiGetGroupDiscussionTopicsRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetGroupDiscussionTopicsResponse> {
            return localVarFp.getGroupDiscussionTopics(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a group
         * @param {PublicApiGetGroupInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInfo(requestParameters: PublicApiGetGroupInfoRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetGroupInfoResponse> {
            return localVarFp.getGroupInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of pool photos for a given group
         * @param {PublicApiGetGroupPoolPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPoolPhotos(requestParameters: PublicApiGetGroupPoolPhotosRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetGroupPoolPhotosResponse> {
            return localVarFp.getGroupPoolPhotos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a group discussion topic
         * @param {PublicApiGetGroupTopicInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupTopicInfo(requestParameters: PublicApiGetGroupTopicInfoRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetGroupTopicInfoResponse> {
            return localVarFp.getGroupTopicInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a group topic reply
         * @param {PublicApiGetGroupTopicRepliesInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupTopicRepliesInfo(requestParameters: PublicApiGetGroupTopicRepliesInfoRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetGroupTopicRepliesInfoResponse> {
            return localVarFp.getGroupTopicRepliesInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an oauth token and oauth token secret
         * @param {PublicApiGetOAuthTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthToken(requestParameters: PublicApiGetOAuthTokenRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getOAuthToken(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a person
         * @param {PublicApiGetPersonInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonInformation(requestParameters: PublicApiGetPersonInformationRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPersonInformationResponse> {
            return localVarFp.getPersonInformation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
         * @param {PublicApiGetPhotoExifRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoExif(requestParameters: PublicApiGetPhotoExifRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotoExifResponse> {
            return localVarFp.getPhotoExif(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a photo
         * @param {PublicApiGetPhotoInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoInfo(requestParameters: PublicApiGetPhotoInfoRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotoInfoResponse> {
            return localVarFp.getPhotoInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of available photo licenses for Flickr
         * @param {PublicApiGetPhotoLicensesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoLicenses(requestParameters: PublicApiGetPhotoLicensesRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotoLicensesResponse> {
            return localVarFp.getPhotoLicenses(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns next and previous photos in a photo list
         * @param {PublicApiGetPhotoListContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoListContext(requestParameters: PublicApiGetPhotoListContextRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotoListContextResponse> {
            return localVarFp.getPhotoListContext(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns next and previous photos for a photo in a set
         * @param {PublicApiGetPhotoSetContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoSetContext(requestParameters: PublicApiGetPhotoSetContextRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotoSetContextResponse> {
            return localVarFp.getPhotoSetContext(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns photo sizes
         * @param {PublicApiGetPhotoSizesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoSizes(requestParameters: PublicApiGetPhotoSizesRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotoSizesResponse> {
            return localVarFp.getPhotoSizes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns next and previous photos for a photo in a photostream
         * @param {PublicApiGetPhotostreamContextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotostreamContext(requestParameters: PublicApiGetPhotostreamContextRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetPhotostreamContextResponse> {
            return localVarFp.getPhotostreamContext(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the albums belonging to the specified user
         * @param {PublicApiGetUserAlbumsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAlbums(requestParameters: PublicApiGetUserAlbumsRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetUserAlbumsResponse> {
            return localVarFp.getUserAlbums(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Return photos from the given user\'s photostream
         * @param {PublicApiGetUserPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPhotos(requestParameters: PublicApiGetUserPhotosRequest, options?: AxiosRequestConfig): AxiosPromise<PublicGetUserPhotosResponse> {
            return localVarFp.getUserPhotos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of photos matching some criteria.
         * @param {PublicApiSearchPhotosRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPhotos(requestParameters: PublicApiSearchPhotosRequest, options?: AxiosRequestConfig): AxiosPromise<PublicSearchPhotosResponse> {
            return localVarFp.searchPhotos(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a new photo to Flickr
         * @param {PublicApiUploadPhotoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhoto(requestParameters: PublicApiUploadPhotoRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uploadPhoto(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for flickrGroupsPoolsGetContext operation in PublicApi.
 * @export
 * @interface PublicApiFlickrGroupsPoolsGetContextRequest
 */
export type PublicApiFlickrGroupsPoolsGetContextRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiFlickrGroupsPoolsGetContext
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiFlickrGroupsPoolsGetContext
    */
    readonly photoId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiFlickrGroupsPoolsGetContext
    */
    readonly groupId?: string
    
}

/**
 * Request parameters for getAccessToken operation in PublicApi.
 * @export
 * @interface PublicApiGetAccessTokenRequest
 */
export type PublicApiGetAccessTokenRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthConsumerKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthNonce: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthTimestamp: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthSignatureMethod: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthVersion: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthSignature: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthVerifier: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAccessToken
    */
    readonly oauthToken: string
    
}

/**
 * Request parameters for getAlbumPhotos operation in PublicApi.
 * @export
 * @interface PublicApiGetAlbumPhotosRequest
 */
export type PublicApiGetAlbumPhotosRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAlbumPhotos
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetAlbumPhotos
    */
    readonly photosetId: string
    
}

/**
 * Request parameters for getFavoritePhotos operation in PublicApi.
 * @export
 * @interface PublicApiGetFavoritePhotosRequest
 */
export type PublicApiGetFavoritePhotosRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFavoritePhotos
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFavoritePhotos
    */
    readonly userId: string
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetFavoritePhotos
    */
    readonly minFaveDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetFavoritePhotos
    */
    readonly maxFaveDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetFavoritePhotos
    */
    readonly page?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetFavoritePhotos
    */
    readonly perPage?: number
    
}

/**
 * Request parameters for getFavoritesContext operation in PublicApi.
 * @export
 * @interface PublicApiGetFavoritesContextRequest
 */
export type PublicApiGetFavoritesContextRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFavoritesContext
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFavoritesContext
    */
    readonly photoId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFavoritesContext
    */
    readonly userId?: string
    
}

/**
 * Request parameters for getFlickrTestEcho operation in PublicApi.
 * @export
 * @interface PublicApiGetFlickrTestEchoRequest
 */
export type PublicApiGetFlickrTestEchoRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFlickrTestEcho
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetFlickrTestEcho
    */
    readonly echo?: string
    
}

/**
 * Request parameters for getGalleryPhotos operation in PublicApi.
 * @export
 * @interface PublicApiGetGalleryPhotosRequest
 */
export type PublicApiGetGalleryPhotosRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGalleryPhotos
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGalleryPhotos
    */
    readonly galleryId: string
    
}

/**
 * Request parameters for getGroupDiscussionTopics operation in PublicApi.
 * @export
 * @interface PublicApiGetGroupDiscussionTopicsRequest
 */
export type PublicApiGetGroupDiscussionTopicsRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupDiscussionTopics
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupDiscussionTopics
    */
    readonly groupId?: string
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetGroupDiscussionTopics
    */
    readonly page?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetGroupDiscussionTopics
    */
    readonly perPage?: number
    
}

/**
 * Request parameters for getGroupInfo operation in PublicApi.
 * @export
 * @interface PublicApiGetGroupInfoRequest
 */
export type PublicApiGetGroupInfoRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupInfo
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupInfo
    */
    readonly groupId?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupInfo
    */
    readonly groupPathAlias?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupInfo
    */
    readonly lang?: string
    
}

/**
 * Request parameters for getGroupPoolPhotos operation in PublicApi.
 * @export
 * @interface PublicApiGetGroupPoolPhotosRequest
 */
export type PublicApiGetGroupPoolPhotosRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupPoolPhotos
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupPoolPhotos
    */
    readonly groupId?: string
    
}

/**
 * Request parameters for getGroupTopicInfo operation in PublicApi.
 * @export
 * @interface PublicApiGetGroupTopicInfoRequest
 */
export type PublicApiGetGroupTopicInfoRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicInfo
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicInfo
    */
    readonly topicId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicInfo
    */
    readonly groupId?: string
    
}

/**
 * Request parameters for getGroupTopicRepliesInfo operation in PublicApi.
 * @export
 * @interface PublicApiGetGroupTopicRepliesInfoRequest
 */
export type PublicApiGetGroupTopicRepliesInfoRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicRepliesInfo
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicRepliesInfo
    */
    readonly topicId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicRepliesInfo
    */
    readonly replyId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetGroupTopicRepliesInfo
    */
    readonly groupId?: string
    
}

/**
 * Request parameters for getOAuthToken operation in PublicApi.
 * @export
 * @interface PublicApiGetOAuthTokenRequest
 */
export type PublicApiGetOAuthTokenRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthConsumerKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthNonce: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthTimestamp: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthSignatureMethod: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthVersion: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthSignature: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetOAuthToken
    */
    readonly oauthCallback: string
    
}

/**
 * Request parameters for getPersonInformation operation in PublicApi.
 * @export
 * @interface PublicApiGetPersonInformationRequest
 */
export type PublicApiGetPersonInformationRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPersonInformation
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPersonInformation
    */
    readonly userId?: string
    
}

/**
 * Request parameters for getPhotoExif operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotoExifRequest
 */
export type PublicApiGetPhotoExifRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoExif
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoExif
    */
    readonly photoId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoExif
    */
    readonly secret?: string
    
}

/**
 * Request parameters for getPhotoInfo operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotoInfoRequest
 */
export type PublicApiGetPhotoInfoRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoInfo
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoInfo
    */
    readonly photoId: string
    
}

/**
 * Request parameters for getPhotoLicenses operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotoLicensesRequest
 */
export type PublicApiGetPhotoLicensesRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoLicenses
    */
    readonly apiKey: string
    
}

/**
 * Request parameters for getPhotoListContext operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotoListContextRequest
 */
export type PublicApiGetPhotoListContextRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoListContext
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoListContext
    */
    readonly photoId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoListContext
    */
    readonly photolistId: string
    
}

/**
 * Request parameters for getPhotoSetContext operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotoSetContextRequest
 */
export type PublicApiGetPhotoSetContextRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoSetContext
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoSetContext
    */
    readonly photoId: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoSetContext
    */
    readonly photosetId?: string
    
}

/**
 * Request parameters for getPhotoSizes operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotoSizesRequest
 */
export type PublicApiGetPhotoSizesRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoSizes
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotoSizes
    */
    readonly photoId: string
    
}

/**
 * Request parameters for getPhotostreamContext operation in PublicApi.
 * @export
 * @interface PublicApiGetPhotostreamContextRequest
 */
export type PublicApiGetPhotostreamContextRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotostreamContext
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetPhotostreamContext
    */
    readonly photoId: string
    
}

/**
 * Request parameters for getUserAlbums operation in PublicApi.
 * @export
 * @interface PublicApiGetUserAlbumsRequest
 */
export type PublicApiGetUserAlbumsRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetUserAlbums
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetUserAlbums
    */
    readonly userId: string
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserAlbums
    */
    readonly page?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserAlbums
    */
    readonly perPage?: number
    
}

/**
 * Request parameters for getUserPhotos operation in PublicApi.
 * @export
 * @interface PublicApiGetUserPhotosRequest
 */
export type PublicApiGetUserPhotosRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetUserPhotos
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiGetUserPhotos
    */
    readonly userId: string
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly safeSearch?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly minUploadDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly maxUploadDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly minTakenDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly maxTakenDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly contentType?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly privacyFilter?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly page?: number
    
    /**
    * 
    * @type {number}
    * @memberof PublicApiGetUserPhotos
    */
    readonly perPage?: number
    
}

/**
 * Request parameters for searchPhotos operation in PublicApi.
 * @export
 * @interface PublicApiSearchPhotosRequest
 */
export type PublicApiSearchPhotosRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly apiKey: string
    
    /**
    * A free text search. Photos who\'s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly text?: string
    
    /**
    * A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly tags?: string
    
    /**
    * The NSID of the user who\'s photo to search. If this parameter isn\'t passed then everybody\'s public photos will be searched. A value of \"me\" will search against the calling user\'s photos for authenticated calls.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly userId?: string
    
    /**
    * Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly minUploadDate?: string
    
    /**
    * Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly maxUploadDate?: string
    
    /**
    * Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly minTakenDate?: string
    
    /**
    * Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly maxTakenDate?: string
    
    /**
    * The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly license?: string
    
    /**
    * The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance. 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly sort?: string
    
    /**
    * Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends & family,   5: completely private photos 
    * @type {number}
    * @memberof PublicApiSearchPhotos
    */
    readonly privacyFilter?: number
    
    /**
    * A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly bbox?: string
    
    /**
    * Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly accuracy?: string
    
    /**
    * Safe search setting:   1: for safe,   2: for moderate,   3: for restricted 
    * @type {number}
    * @memberof PublicApiSearchPhotos
    */
    readonly safeSearch?: number
    
    /**
    * Content Type setting:   1: photos only.   2: screenshots only.   3: \'other\' only.   4: photos and screenshots.   5: screenshots and \'other\'.   6: photos and \'other\'.   7: photos, screenshots, and \'other\' (all). 
    * @type {number}
    * @memberof PublicApiSearchPhotos
    */
    readonly contentType?: number
    
    /**
    * Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the \'dc\' namespace : \"machine_tags\" => \"dc:\" Find photos with a title in the \'dc\' namespace : \"machine_tags\" => \"dc:title=\" Find photos titled \"mr. camera\" in the \'dc\' namespace : \"machine_tags\" => \"dc:title=\\\"mr. camera\\\" Find photos whose value is \"mr. camera\" : \"machine_tags\" => \"*:*=\\\"mr. camera\\\"\" Find photos that have a title, in any namespace : \"machine_tags\" => \"*:title=\" Find photos that have a title, in any namespace, whose value is \"mr. camera\" : \"machine_tags\" => \"*:title=\\\"mr. camera\\\"\" Find photos, in the \'dc\' namespace whose value is \"mr. camera\" : \"machine_tags\" => \"dc:*=\\\"mr. camera\\\"\" Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \"AND\" queries are limited to (16) machine tags. \"OR\" queries are limited to (8). 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly machineTags?: string
    
    /**
    * Either \'any\' for an OR combination of tags, or \'all\' for an AND combination. Defaults to \'any\' if not specified.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly machineTagMode?: string
    
    /**
    * The id of a group who\'s pool to search. If specified, only matching photos posted to the group\'s pool will be returned.
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly groupId?: string
    
    /**
    * Search your contacts. Either \'all\' or \'ff\' for just friends and family. (Experimental)
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly contacts?: string
    
    /**
    * A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present).
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly woeId?: string
    
    /**
    * A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly placeId?: string
    
    /**
    * Filter results by media type. Possible values are all (default), photos or videos
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly media?: string
    
    /**
    * Any photo that has been geotagged, or if the value is \"0\" any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly hasGeo?: string
    
    /**
    * Geo context is a numeric value representing the photo\'s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \"indoors\" or \"outdoors\". The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly geoContext?: string
    
    /**
    * A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly lat?: string
    
    /**
    * A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future). 
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly lon?: string
    
    /**
    * A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km).
    * @type {number}
    * @memberof PublicApiSearchPhotos
    */
    readonly radius?: number
    
    /**
    * The unit of measure when doing radial geo queries. Valid options are \"mi\" (miles) and \"km\" (kilometers). The default is \"km\".
    * @type {string}
    * @memberof PublicApiSearchPhotos
    */
    readonly radiusUnits?: string
    
    /**
    * Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false.
    * @type {boolean}
    * @memberof PublicApiSearchPhotos
    */
    readonly isCommons?: boolean
    
    /**
    * Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos.
    * @type {boolean}
    * @memberof PublicApiSearchPhotos
    */
    readonly inGallery?: boolean
    
    /**
    * Limit the scope of the search to only photos that are for sale on Getty. Default is false.
    * @type {boolean}
    * @memberof PublicApiSearchPhotos
    */
    readonly isGetty?: boolean
    
    /**
    * Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500.
    * @type {number}
    * @memberof PublicApiSearchPhotos
    */
    readonly perPage?: number
    
    /**
    * The page of results to return. If this argument is omitted, it defaults to 1.
    * @type {number}
    * @memberof PublicApiSearchPhotos
    */
    readonly page?: number
    
}

/**
 * Request parameters for uploadPhoto operation in PublicApi.
 * @export
 * @interface PublicApiUploadPhotoRequest
 */
export type PublicApiUploadPhotoRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly apiKey: string
    
    /**
    * 
    * @type {Uint8Array | File | buffer.File}
    * @memberof PublicApiUploadPhoto
    */
    readonly photo: Uint8Array | File | buffer.File
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly tags?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly title?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly description?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly contentType?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly hidden?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly isFamily?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly isFriend?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly isPublic?: string
    
    /**
    * 
    * @type {string}
    * @memberof PublicApiUploadPhoto
    */
    readonly safetyLevel?: string
    
} & PublicUploadPhotoRequest

/**
 * PublicApiGenerated - object-oriented interface
 * @export
 * @class PublicApiGenerated
 * @extends {BaseAPI}
 */
export class PublicApiGenerated extends BaseAPI {
    /**
     * Returns next and previous photos for a photo in a group pool
     * @param {PublicApiFlickrGroupsPoolsGetContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public flickrGroupsPoolsGetContext(requestParameters: PublicApiFlickrGroupsPoolsGetContextRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).flickrGroupsPoolsGetContext(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an access token
     * @param {PublicApiGetAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getAccessToken(requestParameters: PublicApiGetAccessTokenRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getAccessToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of photos in an album.
     * @param {PublicApiGetAlbumPhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getAlbumPhotos(requestParameters: PublicApiGetAlbumPhotosRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getAlbumPhotos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the user\'s favorite photos. Only photos which the calling user has permission to see are returned.
     * @param {PublicApiGetFavoritePhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getFavoritePhotos(requestParameters: PublicApiGetFavoritePhotosRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getFavoritePhotos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns next and previous favorites for a photo in a user\'s favorites
     * @param {PublicApiGetFavoritesContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getFavoritesContext(requestParameters: PublicApiGetFavoritesContextRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getFavoritesContext(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Echos the input parameters back in the response
     * @param {PublicApiGetFlickrTestEchoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getFlickrTestEcho(requestParameters: PublicApiGetFlickrTestEchoRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getFlickrTestEcho(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of photos in a gallery.
     * @param {PublicApiGetGalleryPhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getGalleryPhotos(requestParameters: PublicApiGetGalleryPhotosRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getGalleryPhotos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of discussion topics in a group.
     * @param {PublicApiGetGroupDiscussionTopicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getGroupDiscussionTopics(requestParameters: PublicApiGetGroupDiscussionTopicsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getGroupDiscussionTopics(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a group
     * @param {PublicApiGetGroupInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getGroupInfo(requestParameters: PublicApiGetGroupInfoRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getGroupInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of pool photos for a given group
     * @param {PublicApiGetGroupPoolPhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getGroupPoolPhotos(requestParameters: PublicApiGetGroupPoolPhotosRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getGroupPoolPhotos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a group discussion topic
     * @param {PublicApiGetGroupTopicInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getGroupTopicInfo(requestParameters: PublicApiGetGroupTopicInfoRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getGroupTopicInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a group topic reply
     * @param {PublicApiGetGroupTopicRepliesInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getGroupTopicRepliesInfo(requestParameters: PublicApiGetGroupTopicRepliesInfoRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getGroupTopicRepliesInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an oauth token and oauth token secret
     * @param {PublicApiGetOAuthTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getOAuthToken(requestParameters: PublicApiGetOAuthTokenRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getOAuthToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a person
     * @param {PublicApiGetPersonInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPersonInformation(requestParameters: PublicApiGetPersonInformationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPersonInformation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
     * @param {PublicApiGetPhotoExifRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotoExif(requestParameters: PublicApiGetPhotoExifRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotoExif(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a photo
     * @param {PublicApiGetPhotoInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotoInfo(requestParameters: PublicApiGetPhotoInfoRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotoInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a list of available photo licenses for Flickr
     * @param {PublicApiGetPhotoLicensesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotoLicenses(requestParameters: PublicApiGetPhotoLicensesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotoLicenses(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns next and previous photos in a photo list
     * @param {PublicApiGetPhotoListContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotoListContext(requestParameters: PublicApiGetPhotoListContextRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotoListContext(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns next and previous photos for a photo in a set
     * @param {PublicApiGetPhotoSetContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotoSetContext(requestParameters: PublicApiGetPhotoSetContextRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotoSetContext(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns photo sizes
     * @param {PublicApiGetPhotoSizesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotoSizes(requestParameters: PublicApiGetPhotoSizesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotoSizes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns next and previous photos for a photo in a photostream
     * @param {PublicApiGetPhotostreamContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getPhotostreamContext(requestParameters: PublicApiGetPhotostreamContextRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPhotostreamContext(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the albums belonging to the specified user
     * @param {PublicApiGetUserAlbumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getUserAlbums(requestParameters: PublicApiGetUserAlbumsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUserAlbums(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return photos from the given user\'s photostream
     * @param {PublicApiGetUserPhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public getUserPhotos(requestParameters: PublicApiGetUserPhotosRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUserPhotos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of photos matching some criteria.
     * @param {PublicApiSearchPhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public searchPhotos(requestParameters: PublicApiSearchPhotosRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).searchPhotos(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a new photo to Flickr
     * @param {PublicApiUploadPhotoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApiGenerated
     */
    public uploadPhoto(requestParameters: PublicApiUploadPhotoRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).uploadPhoto(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
